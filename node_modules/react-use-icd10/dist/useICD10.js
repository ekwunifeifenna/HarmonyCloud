var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { useEffect, useRef, useReducer } from 'react';
import axios from 'axios';
import makeCancelableRequest from './makeCancelableRequest';
import parseResponse from './parseResponse';
import getCurrentValues from './getCurrentValues';
import hasInvalidChars from './hasInvalidChars';
import makeNewIcd10 from './makeNewIcd10';
const initialState = {
    fetching: false,
    fetched: false,
    fetchError: null,
    codes: [],
    results: {},
    total: 0,
};
const reducer = (state, action) => {
    switch (action.type) {
        case 'fetching':
            return Object.assign({}, state, { fetching: true });
        case 'fetched':
            return Object.assign({}, state, { fetching: false, fetched: true, codes: action.results.codes, results: action.results.results, total: action.results.total });
        case 'fetch-failed':
            return Object.assign({}, state, { fetching: false, fetched: false, fetchError: action.error });
        case 'no-results':
            return Object.assign({}, state, { fetching: false, fetched: false, fetchError: null });
        default:
            return state;
    }
};
const useICD10 = ({ toString } = {}) => {
    const isMounted = useRef(true);
    const [state, dispatch] = useReducer(reducer, initialState);
    const callSearch = makeCancelableRequest();
    const onSearch = (e) => __awaiter(this, void 0, void 0, function* () {
        e.persist();
        const keyword = e.target.value;
        if (!keyword)
            return;
        if (keyword) {
            try {
                dispatch({ type: 'fetching' });
                const { data = [] } = yield callSearch(keyword);
                const parsedResults = parseResponse(data);
                if (parsedResults && parsedResults.codes.length) {
                    if (isMounted.current) {
                        dispatch({ type: 'fetched', results: parsedResults });
                    }
                }
                else
                    dispatch({ type: 'no-results' });
            }
            catch (error) {
                if (isMounted.current && !axios.isCancel(error)) {
                    dispatch({ type: 'fetch-failed', error });
                }
            }
        }
    });
    const filterer = (inputValue = '') => (acc = [], code) => {
        let shouldShow = false;
        const diagnosisResult = state.results[code] || '';
        if (hasInvalidChars(inputValue))
            return acc;
        const searchRegex = new RegExp(inputValue, 'i');
        if (!inputValue)
            shouldShow = true;
        else if (searchRegex.test(diagnosisResult))
            shouldShow = true;
        else if (searchRegex.test(code))
            shouldShow = true;
        if (shouldShow)
            acc.push(code);
        return acc;
    };
    const toStringDefault = (code) => state.results[code] ? `${code}: ${state.results[code].toUpperCase()}` : '';
    useEffect(() => {
        return () => {
            isMounted.current = false;
        };
    }, []);
    return Object.assign({}, state, { onSearch,
        filterer, toString: toString || toStringDefault, makeNewIcd10,
        getCurrentValues });
};
export default useICD10;
